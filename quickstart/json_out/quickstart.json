{
  "qiskit-terra": {
    "bell": [
      "from qiskit.primitives import Sampler",
      "sampler = Sampler()",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit.primitives import Estimator",
      "estimator = Estimator()",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-ibm-runtime": {
    "bell": [
      "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler",
      "service = QiskitRuntimeService()",
      "backend = service.backend(\"ibmq_qasm_simulator\")",
      "sampler = Sampler(session=backend)",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_ibm_runtime import QiskitRuntimeService, Estimator",
      "service = QiskitRuntimeService()",
      "backend = service.backend(\"ibmq_qasm_simulator\")",
      "estimator = Estimator(session=backend)",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-ibm-provider": {
    "bell": [
      "from qiskit_ibm_provider import IBMProvider",
      "from qiskit.primitives import BackendSampler",
      "provider = IBMProvider()",
      "backend = provider.get_backend(\"ibmq_qasm_simulator\")",
      "sampler = BackendSampler(backend)",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_ibm_provider import IBMProvider",
      "from qiskit.primitives import BackendEstimator",
      "provider = IBMProvider()",
      "backend = provider.get_backend(\"ibmq_qasm_simulator\")",
      "estimator = BackendEstimator(backend)",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-ionq-provider": {
    "bell": [
      "from qiskit_ionq import IonQProvider",
      "from qiskit.primitives import BackendSampler",
      "provider = IonQProvider(\"MY_IONQ_TOKEN\")",
      "backend = provider.get_backend(\"ionq_simulator\")",
      "sampler = BackendSampler(backend)",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_ionq import IonQProvider",
      "from qiskit.primitives import BackendEstimator",
      "provider = IonQProvider(\"MY_IONQ_TOKEN\")",
      "backend = provider.get_backend(\"ionq_simulator\")",
      "estimator = BackendEstimator(backend)",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-quantinuum-provider": {
    "bell": [
      "from qiskit_quantinuum import Quantinuum",
      "from qiskit.primitives import BackendSampler",
      "backend = Quantinuum.backends(\"DEVICE_NAME\")",
      "sampler = BackendSampler(backend)",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_quantinuum import Quantinuum",
      "from qiskit.primitives import BackendEstimator",
      "backend = Quantinuum.backends(\"DEVICE_NAME\")",
      "estimator = BackendEstimator(backend)",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-aer": {
    "bell": [
      "from qiskit_aer import Sampler",
      "sampler = Sampler()",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_aer import Estimator",
      "estimator = Estimator()",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  "qiskit-braket-provider": {
    "bell": [
      "from qiskit_braket_provider import AWSBraketProvider",
      "from qiskit.primitives import BackendSampler",
      "provider = AWSBraketProvider()",
      "backend = provider.backends(\"SV1\")",
      "sampler = BackendSampler(backend)",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ],
    "vqe": [
      "from qiskit_braket_provider import AWSBraketProvider",
      "from qiskit.primitives import BackendEstimator",
      "provider = AWSBraketProvider()",
      "backend = provider.backends(\"SV1\")",
      "estimator = BackendEstimator(backend)",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  }
}