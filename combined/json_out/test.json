[
  {
    "name": "bell",
    "runMethod": "sampler",
    "code": "# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\njob = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)\n",
    "full_code": [
      "from qiskit_aer.primitives import Sampler",
      "sampler = Sampler()",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ]
  },
  {
    "name": "vqe",
    "runMethod": "estimator",
    "code": "from qiskit.quantum_info import SparsePauliOp\n\nH2_op = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\nansatz = TwoLocal(2, \"ry\", \"cz\")\noptimizer = SLSQP(maxiter=1000)\nvqe = VQE(estimator, ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_op)\nprint(result.eigenvalue)",
    "full_code": [
      "from qiskit_aer.primitives import Estimator",
      "estimator = Estimator()",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  {
    "name": "bell",
    "runMethod": "backend",
    "code": "# Build and transpile circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\ntranspiled_circuit = transpile(circuit, backend)\n\n# Run the circuit and get result\njob = backend.run(transpiled_circuit)\ncounts = job.result().get_counts()\nprint(counts)\n",
    "full_code": [
      "from qiskit_aer import AerSimulator",
      "backend = AerSimulator()",
      "&nbsp;",
      "# Build and transpile circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "transpiled_circuit = transpile(circuit, backend)",
      "&nbsp;",
      "# Run the circuit and get result",
      "job = backend.run(transpiled_circuit)",
      "counts = job.result().get_counts()",
      "print(counts)"
    ]
  },
  {
    "name": "bell",
    "runMethod": "sampler",
    "code": "# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\njob = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)\n",
    "full_code": [
      "from qiskit_aer.primitives import Sampler",
      "sampler = Sampler()",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ]
  },
  {
    "name": "vqe",
    "runMethod": "estimator",
    "code": "from qiskit.quantum_info import SparsePauliOp\n\nH2_op = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\nansatz = TwoLocal(2, \"ry\", \"cz\")\noptimizer = SLSQP(maxiter=1000)\nvqe = VQE(estimator, ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_op)\nprint(result.eigenvalue)",
    "full_code": [
      "from qiskit_aer.primitives import Estimator",
      "estimator = Estimator()",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  },
  {
    "name": "bell",
    "runMethod": "backend",
    "code": "# Build and transpile circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\ntranspiled_circuit = transpile(circuit, backend)\n\n# Run the circuit and get result\njob = backend.run(transpiled_circuit)\ncounts = job.result().get_counts()\nprint(counts)\n",
    "full_code": [
      "from qiskit_aer import AerSimulator",
      "backend = AerSimulator()",
      "&nbsp;",
      "# Build and transpile circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "transpiled_circuit = transpile(circuit, backend)",
      "&nbsp;",
      "# Run the circuit and get result",
      "job = backend.run(transpiled_circuit)",
      "counts = job.result().get_counts()",
      "print(counts)"
    ]
  },
  {
    "name": "bell",
    "runMethod": "sampler",
    "code": "# Build circuit\nfrom qiskit import QuantumCircuit\ncircuit = QuantumCircuit(2, 2)\ncircuit.h(0)\ncircuit.cx(0,1)\ncircuit.measure([0,1], [0,1])\n\n# Run the circuit and get result distribution\njob = sampler.run(circuit)\nquasi_dist = job.result().quasi_dists[0]\nprint(quasi_dist)\n",
    "full_code": [
      "from qiskit_aer.primitives import Sampler",
      "sampler = Sampler()",
      "&nbsp;",
      "# Build circuit",
      "from qiskit import QuantumCircuit",
      "circuit = QuantumCircuit(2, 2)",
      "circuit.h(0)",
      "circuit.cx(0,1)",
      "circuit.measure([0,1], [0,1])",
      "&nbsp;",
      "# Run the circuit and get result distribution",
      "job = sampler.run(circuit)",
      "quasi_dist = job.result().quasi_dists[0]",
      "print(quasi_dist)"
    ]
  },
  {
    "name": "vqe",
    "runMethod": "estimator",
    "code": "from qiskit.quantum_info import SparsePauliOp\n\nH2_op = SparsePauliOp.from_list([\n    (\"II\", -1.052373245772859),\n    (\"IZ\", 0.39793742484318045),\n    (\"ZI\", -0.39793742484318045),\n    (\"ZZ\", -0.01128010425623538),\n    (\"XX\", 0.18093119978423156)\n])\n\n# Calculate ground state energy using VQE\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\n\nansatz = TwoLocal(2, \"ry\", \"cz\")\noptimizer = SLSQP(maxiter=1000)\nvqe = VQE(estimator, ansatz, optimizer)\nresult = vqe.compute_minimum_eigenvalue(operator=H2_op)\nprint(result.eigenvalue)",
    "full_code": [
      "from qiskit_aer.primitives import Estimator",
      "estimator = Estimator()",
      "&nbsp;",
      "from qiskit.quantum_info import SparsePauliOp",
      "&nbsp;",
      "H2_op = SparsePauliOp.from_list([",
      "    (\"II\", -1.052373245772859),",
      "    (\"IZ\", 0.39793742484318045),",
      "    (\"ZI\", -0.39793742484318045),",
      "    (\"ZZ\", -0.01128010425623538),",
      "    (\"XX\", 0.18093119978423156)",
      "])",
      "&nbsp;",
      "# Calculate ground state energy using VQE",
      "from qiskit.circuit.library import TwoLocal",
      "from qiskit.algorithms.optimizers import SLSQP",
      "from qiskit.algorithms.minimum_eigensolvers import VQE",
      "&nbsp;",
      "ansatz = TwoLocal(2, \"ry\", \"cz\")",
      "optimizer = SLSQP(maxiter=1000)",
      "vqe = VQE(estimator, ansatz, optimizer)",
      "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
      "print(result.eigenvalue)"
    ]
  }
]