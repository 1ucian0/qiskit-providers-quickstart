[
  {
    "title": "IBM Qiskit Runtime",
    "category": "hardware",
    "image": "static/images/providers/qiskit-ibm-runtime.png",
    "description": "Qiskit Runtime is a quantum computing service and programming model that allows users to optimize workloads and efficiently execute them on quantum systems at scale. The programming model extends the existing interface in Qiskit with a set of new primitive programs.",
    "installation": "pip install qiskit-ibm-runtime",
    "websiteCta": {
      "label": "Website",
      "url": "https://quantum-computing.ibm.com/lab/docs/iql/runtime/"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/qiskit_ibm_runtime/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-ibm-runtime"
    },
    "code": {
      "sampler": "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler\nservice = QiskitRuntimeService()\nbackend = service.backend(\"ibmq_qasm_simulator\")\nsampler = Sampler(session=backend)"
    },
    "codeExamples": [
      {
        "name": "bell",
        "runMethod": "sampler",
        "full_code": [
          "from qiskit_ibm_runtime import QiskitRuntimeService, Sampler",
          "service = QiskitRuntimeService()",
          "backend = service.backend(\"ibmq_qasm_simulator\")",
          "sampler = Sampler(session=backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "vqe",
        "runMethod": "estimator",
        "full_code": [
          "from qiskit_ibm_runtime import QiskitRuntimeService, Estimator",
          "service = QiskitRuntimeService()",
          "backend = service.backend(\"ibmq_qasm_simulator\")",
          "estimator = Estimator(session=backend)",
          "&nbsp;",
          "from qiskit.quantum_info import SparsePauliOp",
          "&nbsp;",
          "H2_op = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(2, \"ry\", \"cz\")",
          "optimizer = SLSQP(maxiter=1000)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "IBM Quantum Platform",
    "category": "hardware",
    "image": "static/images/providers/qiskit-ibm-provider.png",
    "description": "IBM Quantum platform offers access to IBM Quantum systems and simulators.",
    "installation": "pip install qiskit-ibm-provider",
    "websiteCta": {
      "label": "Website",
      "url": "https://www.ibm.com/quantum/systems"
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/partners/qiskit_ibm_provider/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-ibm-provider"
    },
    "code": {
      "backend": "from qiskit_ibm_provider import IBMProvider\nprovider = IBMProvider()\nbackend = provider.get_backend(\"ibmq_qasm_simulator\")"
    },
    "codeExamples": [
      {
        "name": "bell",
        "runMethod": "backend",
        "full_code": [
          "from qiskit_ibm_provider import IBMProvider",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibmq_qasm_simulator\")",
          "&nbsp;",
          "# Build and transpile circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "transpiled_circuit = transpile(circuit, backend)",
          "&nbsp;",
          "# Run the circuit and get result",
          "job = backend.run(transpiled_circuit)",
          "counts = job.result().get_counts()",
          "print(counts)"
        ]
      },
      {
        "name": "bell",
        "runMethod": "sampler",
        "full_code": [
          "from qiskit_ibm_provider import IBMProvider",
          "from qiskit.primitives import BackendSampler",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibmq_qasm_simulator\")",
          "sampler = BackendSampler(backend)",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "vqe",
        "runMethod": "estimator",
        "full_code": [
          "from qiskit_ibm_provider import IBMProvider",
          "from qiskit.primitives import BackendEstimator",
          "provider = IBMProvider()",
          "backend = provider.get_backend(\"ibmq_qasm_simulator\")",
          "estimator = BackendEstimator(backend)",
          "&nbsp;",
          "from qiskit.quantum_info import SparsePauliOp",
          "&nbsp;",
          "H2_op = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(2, \"ry\", \"cz\")",
          "optimizer = SLSQP(maxiter=1000)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  },
  {
    "title": "Qiskit Aer",
    "category": "simulator",
    "image": null,
    "description": "Qiskit Aer is a high performance simulator for quantum circuits that includes noise models.",
    "installation": "pip install qiskit-aer",
    "websiteCta": {
      "label": null,
      "url": null
    },
    "docsCta": {
      "label": "Docs",
      "url": "https://qiskit.org/documentation/aer/"
    },
    "sourceCta": {
      "label": "GitHub",
      "url": "https://github.com/Qiskit/qiskit-aer"
    },
    "code": {
      "sampler": "from qiskit_aer.primitives import Sampler\nsampler = Sampler()",
      "backend": "from qiskit_aer import AerSimulator\nbackend = AerSimulator()"
    },
    "codeExamples": [
      {
        "name": "bell",
        "runMethod": "backend",
        "full_code": [
          "from qiskit_aer import AerSimulator",
          "backend = AerSimulator()",
          "&nbsp;",
          "# Build and transpile circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "transpiled_circuit = transpile(circuit, backend)",
          "&nbsp;",
          "# Run the circuit and get result",
          "job = backend.run(transpiled_circuit)",
          "counts = job.result().get_counts()",
          "print(counts)"
        ]
      },
      {
        "name": "bell",
        "runMethod": "sampler",
        "full_code": [
          "from qiskit_aer.primitives import Sampler",
          "sampler = Sampler()",
          "&nbsp;",
          "# Build circuit",
          "from qiskit import QuantumCircuit",
          "circuit = QuantumCircuit(2, 2)",
          "circuit.h(0)",
          "circuit.cx(0,1)",
          "circuit.measure([0,1], [0,1])",
          "&nbsp;",
          "# Run the circuit and get result distribution",
          "job = sampler.run(circuit)",
          "quasi_dist = job.result().quasi_dists[0]",
          "print(quasi_dist)"
        ]
      },
      {
        "name": "vqe",
        "runMethod": "estimator",
        "full_code": [
          "from qiskit_aer.primitives import Estimator",
          "estimator = Estimator()",
          "&nbsp;",
          "from qiskit.quantum_info import SparsePauliOp",
          "&nbsp;",
          "H2_op = SparsePauliOp.from_list([",
          "    (\"II\", -1.052373245772859),",
          "    (\"IZ\", 0.39793742484318045),",
          "    (\"ZI\", -0.39793742484318045),",
          "    (\"ZZ\", -0.01128010425623538),",
          "    (\"XX\", 0.18093119978423156)",
          "])",
          "&nbsp;",
          "# Calculate ground state energy using VQE",
          "from qiskit.circuit.library import TwoLocal",
          "from qiskit.algorithms.optimizers import SLSQP",
          "from qiskit.algorithms.minimum_eigensolvers import VQE",
          "&nbsp;",
          "ansatz = TwoLocal(2, \"ry\", \"cz\")",
          "optimizer = SLSQP(maxiter=1000)",
          "vqe = VQE(estimator, ansatz, optimizer)",
          "result = vqe.compute_minimum_eigenvalue(operator=H2_op)",
          "print(result.eigenvalue)"
        ]
      }
    ]
  }
]